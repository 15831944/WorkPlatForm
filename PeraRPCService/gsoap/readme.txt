1、src下的文件是修改（WITH_NONAMESPACES）定制过的代码，需要加入到工程中一起编译
2、bin目录下是生成代理根所需的工具
3、如果有新的wsdl，新建一文件夹，放入wsdl文件，按bin中output.bat格式及参数创建一个批处理，并放入当前目录
4、运行批处理，得到output目录及其下6个文件，全部放入工程中一起编译
5、所有加入的cpp文件需要手动设为无预编译头

代码调用示例
	std::string strName("admin");
	std::string strPwd("111");
	ermRemoting::ERMRemotingHttpBindingProxy erm(SOAP_C_UTFSTRING);
	ermRemoting::_ermRemoting1__login dataLogin;
	dataLogin.in0 = &strName;
	dataLogin.in1 = &strPwd;
	ermRemoting::_ermRemoting1__loginResponse dataLoginResponse;
	erm.login(&dataLogin, &dataLoginResponse);
	erm.destroy();

加入自定义头，如ticket认证
<soap:Envelope xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/"
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xmlns:xsd="http://www.w3.org/2001/XMLSchema"
xmlns:soapenc="http://schemas.xmlsoap.org/soap/encoding/"> 
<soap:Header>
<ermTicket>asdfasdfasdf</ermTicket> 
</soap:Header>
<soap:Body>
<remoteRobotOutputInfo
xmlns="http://service.workflow.base.pera.com"><in0>1</in0><in1>asdf</in1><in2></
in2></remoteRobotOutputInfo>
</soap:Body>
</soap:Envelope>

方法如下

gSoap: How to add info to SOAP Header using gSOAP(转)

gSoap: How to add info to SOAP Header using gSOAP
There's some misleading info in gSOAP's official documents in SOAP Header Processing Part. 
This article leads you to the right way and can make your program work.
The use case is: 
Client needs to pass user name and password to Server Side to get authenticated.
The username and password info should be embeded in SOAP Header.
Steps:
1. Edit struct SOAP_ENV__Header in soapStub.h file which is generated by gSOAP's soapcpp2 compiler
Add the neccesary info to this struct 
For example:
The original one is:
struct SOAP_ENV__Header
{
public:
 void *dummy; /* transient */
};
This should be changed to:
struct SOAP_ENV__Header
{
public:
 void *dummy; /* transient */
 char *username;
 char *password;
};
2.  Edit function soap_out_SOAP_ENV__Header in soapC.cpp file which is also generated by gSOAP
Add statements to serialize those info into SOAP Header.
For example:
The original one is:
SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
    soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Header), type);
    /* transient dummy skipped */
    soap_element_end_out(soap, tag);
    return SOAP_OK;
}
This could be changed to:
SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
    soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Header), type);
    /* transient dummy skipped */
    soap_out_string(soap, "headerNS:username", 1, &(a->username), "");
    soap_out_string(soap, "headerNS:password", 2, &(a->password), "");
    soap_element_end_out(soap, tag);
    return SOAP_OK;
}
3. Add the namespace mapping to namespaces array in .nsmap file.
 {"headerNS", "http://customeheader.test.com", NULL, NULL},
 
4. Set the header before invoking Web Service Method. This part you can also refer to the gSOAP's official documenthttp://www.cs.fsu.edu/~engelen/soapdoc2.html#tth_sEc12.
   struct soap soap; 
   soap_init(&soap);  
...
    soap->header = (SOAP_ENV__Header *)soap_malloc(soap, sizeof(SOAP_ENV__Header));
    soap->header->username = (char*)malloc(MAX_NAME_SIZE * sizeof(char));
    soap->header->password = (char*)malloc(MAX_NAME_SIZE * sizeof(char));
    strcpy(soap->header->username, username);
    strcpy(soap->header->password, passwd);
    soap_call_method(&soap, ...);  //the SOAP Header will be in the request
...
5. Compile
6. Run. 
The SOAP Message could be
... 
<SOAP-ENV:Envelope xmlns:headerNS="http://customeheader.vpamws.com">
<SOAP-ENV:Header>
<headerNS:username>admin</headerNS:username>
<headerNS:password>default</headerNS:password>
</SOAP-ENV:Header>
<SOAP-ENV:Body> 
... 
</SOAP-ENV:Body> 
</SOAP-ENV:Envelope>
 
Any Questions, Please let me know. Thanks.
 
-Debora